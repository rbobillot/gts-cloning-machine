#!/usr/bin/python2.7

# A script that acts as the GTS, for sending and receiving pokemon between a
# retail cart and a PC. Credit goes to LordLandon and his sendpkm script, as
# well as the description of the GTS protocol from
# http://projectpokemon.org/wiki/GTS_protocol
#
# - Infinite Recursion

from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from src import gtsvar
from src.pokehaxlib import initServ
from src.getpkm import getpkm
from src.sendpkm import sendpkm
from platform import system
from sys import argv, exit
from time import sleep
import os
import json
import thread

if system() == 'Linux':  # or 'Darwin' # (Mac OSX, but sudo doesn't seem to me needed)
    if os.getuid() != 0:
        print 'Program must be run as superuser. Enter your password below',
        print 'if prompted.'
        os.system('sudo ' + argv[0] + ' root')
        exit(0)

print(gtsvar.version)

initServ()
sleep(1)

GTS_SERVICE_HOST = "localhost"
GTS_SERVICE_PORT = 8081


def get_spoof_addr():
    """
    Get the spoofed DNS address, use to connect the NDS to the GTS server
    Either:
     - it comes from the PUBLIC_HOST variable
       (injected here via docker-compose, from the "run" script))
     - it comes from the "spoof_addr.txt" file (created by the dnsspoof function),
       if PUBLIC_HOST is not set (meaning that this script is called outside of docker)
    """
    f = open('spoof_addr.txt', 'r')
    addr = f.read()
    f.close()
    return os.getenv("PUBLIC_HOST", addr)


API_PORT_NUMBER = 8082


class handleRoutes(BaseHTTPRequestHandler):
    def do_GET(self):
        if (self.path == '/'):
            return self.sendResponse('{"status": "ok"}', 200, 'application/json')
        if (self.path.startswith('/')):
            if (self.path.endswith('status')):
                return self.sendResponse(
                    '{"isRunning": true, "status": "%s"}' % (
                        "Running on " + get_spoof_addr()), 200, 'application/json')
            if (self.path.endswith('receive')):
                create_pkm_url = "http://%s:%s/pokemon" % (GTS_SERVICE_HOST, GTS_SERVICE_PORT)
                # for some reason, the result of the sendpkm function is not logged
                # to the console, a solution must be found
                thread.start_new_thread(getpkm, (create_pkm_url,))

                return self.sendResponse('{"action": "receive"}', 200, 'application/json')
        else:
            return self.sendResponse('Not found.', 404, 'text/plain')

    def do_POST(self):
        if (self.path.startswith('/')):
            if (self.path.endswith('send')):
                body = self.rfile.read(int(self.headers['Content-Length']))
                pkm_data_b64 = json.loads(body).get('raw_pkm_data')
                pkm = pkm_data_b64.decode('base64')

                # for some reason, the result of the sendpkm function is not logged
                # to the console, a solution must be found
                thread.start_new_thread(sendpkm, (pkm,))

                return self.sendResponse('{"action": "send"}', 200, 'application/json')

    def sendResponse(self, res, status, type):
        self.send_response(status)
        self.send_header('Content-type', type)
        self.end_headers()
        # Send the html message
        self.wfile.write(res)
        return


try:
    # Create a web server and define the handler to manage the incoming requests
    server = HTTPServer(('', API_PORT_NUMBER), handleRoutes)
    print('Started http server on port %d' % API_PORT_NUMBER)
    # Wait forever for incoming http requests
    server.serve_forever()

except KeyboardInterrupt:
    print('\nServer ended via Keyboard Interrupt.')
    server.socket.close()
    exit(0)
